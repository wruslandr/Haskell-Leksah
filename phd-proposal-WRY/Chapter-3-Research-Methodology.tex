\titleformat {\chapter} {\normalfont\huge\bfseries\color{black}}   {\thechapter}{10pt}{\huge} 
\chapter {Research Methodology}


%% =========================================================
\section{Research Objectives}

The proposed research is to implement a realtime and parallel look-ahead control and feedrate compensation strategy for  CNC reference-pulse interpolation. 
\vspace*{1\baselineskip}

Interpolation is the task that generates the actual reference commands that drives the CNC tool along the different axis-of-motions in the machine, such that, it accurately follows the desired machining path, in a timely and coordinated manner.

\subsection{Research scope} The scope of work proposed for this research study are as follows:
\begin{enumerate}
	\item Start from the provision of G-Codes, specifically RS274D NGC standard G-Code.
	\item Implement reference-pulse CNC interpolation for computational efficiency.
	\item Conduct look-ahead and feedrate error compensation in G-Code interpolation.
	\item Execute realtime, parallel, online/offline computations for the CNC control loop.
	\item Compare appropriate parallel execution methods for 2D/3D G-Code interpolation  
	\item Address designs for extension to 3-axis and 5-axis interpolation implementations.
\end{enumerate}

\subsection{G-Codes Coverage}
We will start from RS274D NGC G-Code files because the format is the base standard for G-Codes supported by all machines used in the CNC industry. Our research does not include SVG or STL files generated by CAD applications. Our research also excludes the generation of G-Codes from CAM processing of SVG or STL input files. Using NURBS interpolation requires a CNC machine capable of handling NURBS G-Code generated tool paths. Since the NURBS G-Code format is proprietary and only used in the high end FANUC CNC machines, NURBS G-Code will not  be in the scope of this research. It should be noted that NURBS G-Code files are not the same as NURBS interpolation method.
%% \vspace*{1\baselineskip}

\subsection{Reference-Pulse Interpolation}
We will implement CNC Reference-Pulse Interpolation instead of Reference-Word interpolation because of computational efficiency. All reference-pulse interpolations are iterative and controlled by an adjustable interrupt clock. Various free and open source software libraries can take advantage of this fact and that makes integration practical. This integration method is also more streamlined with the reference-pulse method. Various implementation methods using these libraries can be explored for computational efficiency.  

\subsection{Look-ahead control}
The feedrate look-ahead control algorithm is introduced to deal with sudden changes of feedrate pulses, essentially the move velocity. Look-ahead control is a pre-processing task of the path contour before real machining takes place. The main goal is to achieve a smooth feedrate (velocity) profile by looking ahead at deceleration regions in the given contour path. The idea of look ahead is to consider velocities to move toward future target points from the current machine position using the geometric path data already provided in the G-Code. That could be one-step forward, or two-step forward look-ahead methods. Using look-ahead control, the movement velocity can then be adjusted continuously to ensure smooth contouring movements, not jerky.

\subsection{Feedrate compensation}
Feedrate compensation is also about adjusting move velocities but with a focus on reducing contouring path errors, instead of maintaining movement smoothness. The two goals are conflicting, meaning, to reduce path errors we need to slow down the machine move velocity. Whereas, to speed up machine movements, we may increase path tracking errors. In this research, we will look at methods that strike a balance in minimizing contour errors, meaning, accurately following the desired machining path, and at the same time achieving a reasonable machining velocity. The term feedrate compensation or velocity compensation is used here to refer to velocity adjustments that have to be made. The target priority is placed on contour tracking accuracy compared to fast machining completion and velocity profile smoothness. Ultimately, there is no point to quickly finish cutting a part when the output machined part itself is not accurately machined.

\subsection{Realtime and parallel execution}
As discussed in Chapter 1, Introduction, our technical concept of realtime execution means every software task must be completed within its start and end timing deadlines, unlike the layman notion of realtime which means running in the current instance of time. In terms of parallel tasks execution, we will consider both software multi-threading and multi-processing methods. Our research strategy is to implement, wherever possible, both task-realtime and task-parallel executions simultaneously. 

\subsection{Parallel execution strategies}
There are various parallel execution strategies that will be considered in CNC interpolation. The signals-and-slots (sigslot) mechanism is one execution strategy that will be used to allow different CNC software modules to inter-operate by calling each other's built-in functions. The sigslot method implements a type-safe, thread-safe signal/slot mechanism in software execution. The parallel executions for the signals-and-slots (signal/slot) method will be discussed further in the section on research implementation plan. 
\vspace{0.5cm}

For example, in the CNC control software (CCS), the different software controller classes must be aware about each other in some detail. The centerpiece or crux of our methodology in the implementation of the CNC Control software is to design and execute the signal/slot algorithm that handles the different software classes through the CNC control loop. 
\vspace{0.5cm}

\pagebreak
The invocation of these classes must happen in a coordinated and timely manner, such that many tasks will be seen running in either serial, parallel or concurrent modes. This inter-operation, signal/slot, and control-loop strategy is the key to the success of our research on CNC interpolation. As discussed in Chapter 1, Introduction, the controller classes handled by the control loop comprise the following:

\begin{enumerate}
	\item G-Code Interpreter class
	\item G-Code Interpolator class
	\item Signal Driver class
	\item Motion Controller class
	\item Error Controller class
	\item Services Controller class
	\item Human-Interface Controller class
\end{enumerate}

\subsection{Extension to 5-axis interpolation}
The proposed research covers the 3-axis CNC Research machine, that we have available for development and experimentation on CNC control implementations. The CNC Research Machine and its details will be described in the next chapter, Chapter 4 on Related Research Work, Section 4.1 with a link here [~\ref{sec:4.1-CNC-Research-Machine}]. We will design the software control infrastructure to be ready for future inclusion and extension that cover 5-axis CNC machines. 

% \pagebreak
%% =========================================================
\section{Research Methodology}

\subsection{Software engineering perspective}

Most of the work in CNC interpolation in published literature are conducted by control and instrument engineers, in which, the perspective is on the control and operational aspects of the CNC machine. We undertake this research project from the perspective of a software engineer, with a focus on exploring different software engineering technologies that can be applied to efficient CNC control operations.  
%% \vspace*{1\baselineskip}

\subsection{Software engineering methods}

Most of the work in CNC interpolation in published literature do not mention specific software programming techniques, data structures, and various tools, that are currently available for use by the software engineer. For CNC interpolation generally, the focus is direct to the mathematical aspects on geometry, path contours, and machine dynamics. Despite having common mention of realtime in CNC literature, the meaning is not in the true sense the correct interpretation of software defined realtime. This subject was discussed earlier in Chapter 1, on Introduction. For CNC machines in particular, with the  readily available multi-cores, multi-processors, and networked computers today, there are less that a handful of CNC specific publications that even mention the word parallel for CNC interpolation. Thus, the two areas of realtime and parallel, are opportunities we will explore in this research.
\vspace{0.5cm}

For realtime software executions, we will implement task time recordings for true realtime using the RTAI (RealTime Application Interface) C/C++ library. For true parallel software executions, we will implement tasks for multi-threading, multi-processing, and parallel file HDF5 I/O  operations using the OpenMPI (Open Message Passing Interface), OpenMP (Open Multi-Processing) and HDF5 (Heirarchical Data Format) C/C++ libraries. For offline CNC interpreter and CNC interpolator executions, we will implement the HDF5 high speed file I/O system. For CNC control loop operations, we will implement the Signal/Slot mechanism that allows programmed invocations and inter-operations of the various controller classes handled by the control loop.

\subsection{Linux, open source and free software}
Most of the work in CNC interpolation in published literature do not use Linux, open source and free software. As expected, Microsoft operating system (OS) seemed to be popular among control and instrument engineers. Except for embedded systems which is micro-controller (MCU) based, most motion-control hardware boards with micro-processors (MCU or CPU) for CNC use are Microsoft OS based. As we discussed in Chapter 1, Introduction, we avoided the Microsoft (MS) Windows platform because we need full and open access to the operating system and to the software components that control the devices attached to the operating system. With the Linux OS, we have full and open access to all software codes.
\vspace{0.5cm}

Our implementation for the CNC control loop and all its component controller classes shall be based primarily on the C/C++ software programming language. We will consider also the Rust programming language as the low-level systems language on par with C/C++. For scripting languages, we will consider Python and Julia to execute non-critical codes in the control loop. For complex mathematical computations, we will consider Octave-NURBS and Scilab-NURBS backend components that will be interfaced to the C/C++ primary control loop codes. 
\vspace{0.5cm}

The software components, Rust, Python, Julia, Octave and Scilab are all open source and cost-free. In addition, all of the mentioned components can run in true parallel mode. For this research project, we have practically opted for total open access to all software components and total cost-free software.

\subsection{Motion control devices}

We will implement the Pico Universal PWM (Pulse Width Modulation) Servo Controller hardware board as our motion controller interface board to the 3-axis servo-controlled CNC Research machine. This is a LinuxCNC based interface board, that can handle the control of a 2-axis, 3-axis or 4-axis machine tool with PWM-driven servo amplifiers. It contains 4 PWM generators with variable PWM drive frequency (variable feedrate), and 4 digital encoder counters as feedback to follow the machine position. The image and specifications of the board can be seen at the link [~\ref{sec:C-3.1-Universal PWM Servo Controller Board}] and Fig. [~\ref{fig:App3-Universal-PWM-Servo-Controller.jpg}] in the appendix.
\vspace{0.5cm}

As comparison, we will implement the 28-Pin LIN (Local Interconnect Network) Demo Microchip Board for PIC16F/PIC18 MCUs as our own-developed interface board to drive the 3-axis servo-controlled CNC Research machine. The PIC Micro-controllers can be programmed from the Linux based MPLAB IDE software application provided by Microchip Corporation. We have sufficient familiarity through previous successful experiences in programming PIC Microcontroller chips. The image and specifications of the board can be seen at the link [~\ref{sec:C-3.3-MCU Microchip 28-Pin LIN Development Board}] and Fig. [~\ref{fig:App3-MCU-Microchip-Dev-Demo-Board.jpg}] in the appendix.
\vspace{0.5cm}

In another variation, we will implement the Microchip Curiosity Development Board Demo for micro-controllers (MCU) as another own-developed interface board to drive the 3-axis servo-controlled CNC Research machine. Similarly, the MCUs can be programmed from the Linux based MPLAB IDE software application provided by Microchip Corporation. This Curiosity Demo Board allows for some user prototyping but not the full prototyping as provided in the 28-Pin-LIN Demo Board. The image and specifications of the board can be seen at the link [~\ref{sec:C-3.5-Curiosity-Development-Board}] and  Fig. [~\ref{fig:App3-MCU-Curiosity-Dev-Board-Layout.jpg}] in the appendix.
\vspace{0.5cm}

Using our own developed CNC Control software, we will compare performance as well as limitations of all three board interface devices for driving the 3-axis servo-controlled CNC Research machine. 
  
\subsection{Research Validation}

It is generally quoted that, \textit{"The proof of the pudding is in the eating."} People say this to mean that something can only be judged to be good or bad after it has been tried or used. 
\vspace{0.5cm}

For contour tracking error, we will compute the deviation from G-Code reference commands by the encoder feedback mechanism from our CNC Research machine servo-motor. This can be accomplished using our Pico Universal PWM Controller hardware board which comes equipped with 4-nos of digital encoder counters as feedback to follow the machine position (X, Y, Z).
\vspace{0.5cm}

For validation of our machining control technique, we will take manual micrometer measurements of our machine part based on 2D models of common objects, like a circular disk, a semi-circular disk, a square plate, a rectangular plate, a pentagon plate or a hexagon plate, a star and so on. These measurements will be compared with the G-Code exact coordinates drawn for those simple models. We will test our CNC Control Software on a real CNC Laser Cutting machine available at UMP for precision cutting.
\vspace{0.5cm}

For realtime and parallel tasks execution, we will capture (dump) in nanoseconds, timing records for the tasks, and save the data in a file, like HDF5 binary files. Parallel I/O HDF5 data formats are used for fast serialization and parallelization of large datasets. The files will later be analyzed to validate actual realtime and/or parallel tasks performance against its design.
% \vspace{0.5cm}

\pagebreak
\section{Summary on Research Methodology}

We will start our research from the point of being provided with the RS274D NGC formatted G-codes. Next, we implement CNC Reference-Pulse interpolation based on the provided G-codes. This is followed by either the one-step forward, or two-step forward look-ahead methods to determine machine move velocity adjustments for smooth overall machining.
\vspace{0.5cm}

The next step is to perform feedrate or velocity compensation, an activity that strikes a balance between achieving contour tracking accuracy against machine movement smoothness. In implementing our CNC control loop execution, our strategy is to implement, wherever possible, both task-realtime and task-parallel executions simultaneously. In the CNC control loop, the parallel executions using the signals-and-slots (signal/slot) method will allow different CNC software modules to inter-operate by calling each other's built-in functions, in both synchronous and asynchronous modes.
\vspace{0.5cm}

It must be noted that the centerpiece or crux of our methodology in the implementation of the CNC control software is to correctly design and execute the signal/slot algorithm that handles the different software classes through the CNC control loop. We shall also design the software control infrastructure to be ready for future extension to cover 5-axis CNC machines.
\vspace{0.5cm}

We undertake this research project from the perspective of a software engineer, with a focus on exploring different software engineering technologies that can be applied to efficient CNC control operations.
\vspace{0.5cm}

Realtime and parallel executions are two opportunities we will explore in this research on CNC interpolation. In addition, for this research project, we opt for total open access to all software components and total cost-free software by including Linux based, open source and only cost-free software resources. For the delivery of the CNC control software product, we will consider inclusion of software components, like Rust, Python, Julia, Octave and Scilab, in addition to the base C/C++ codes.
\vspace{0.5cm}

In this research project, we will implement three(3) hardware interface devices to drive our CNC Research machine, comprising of the Universal PWM (Pulse Width Modulation) Servo Controller board from Pico systems, the 28-Pin LIN (Local Interconnect Network) Demo Board for micro-controllers (MCU) from Microchip Corporation, and the Curiosity Development Board Demo for micro-controllers (MCU) also from Microchip Corporation. Our goal is to develop our own CNC Control software, and use this software to compare performance as well as limitations of all three board interface devices in driving the 3-axis servo-controlled CNC Research machine.
\vspace{0.5cm}

For research validation on our developed CNC Control software, it will be judged as being good or bad after it has been tried or used. We will perform computational assessments, as well as manual measurements of real parts produced to compare them against G-Code exact coordinates and dimensions drawn for the source of some simple 2D models. 
\vspace{0.5cm}

In overview, the proposed research is to implement a realtime and parallel look-ahead control and feedrate compensation strategy for CNC reference-pulse interpolation. The descriptions above summarizes the research methodology for this project.

% ==================================================
