# doc-cache created by Octave 6.2.0
# name: cache
# type: cell
# rows: 3
# columns: 15
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bin_values


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1022
 -- Function File: [X_BIN Y_BIN W_BIN N_BIN] = bin_values(X, Y, K)

     Average values over ranges of one variable
     Given X (size N*1) and Y (N*M), this function splits the range of X
     into up to K intervals (bins) containing approximately equal
     numbers of elements, and for each part of the range computes the
     mean of y.

     Any NaN values are removed.

     Useful for detecting possible nonlinear dependence of Y on X and as
     a preprocessor for spline fitting.  E.g., to make a plot of the
     average behavior of y versus x: 'errorbar(x_bin, y_bin, 1 ./
     sqrt(w_bin)); grid on'

     Inputs:
     X: N*1 real array
     Y: N*M array of values at the coordinates X
     K: Desired number of bins, 'floor(sqrt(n))' by default

     Outputs:
     X_BIN, Y_BIN: Mean values by bin (ordered by increasing X)
     W_BIN: Weights (inverse standard error of each element in Y_BIN;
     note: will be NaN or Inf where N_BIN = 1)
     N_BIN: Number of elements of X per bin

See also: csaps, dedup.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Average values over ranges of one variable
Given X (size N*1) and Y (N*M), th...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
catmullrom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 489
 -- Function File: PP = catmullrom( X, F, V)

     Returns the piecewise polynomial form of the Catmull-Rom cubic
     spline interpolating F at the points X.  If the input V is supplied
     it will be interpreted as the values of the tangents at the
     extremals, if it is missing, the values will be computed from the
     data via one-sided finite difference formulas.  See the wikipedia
     page for "Cubic Hermite spline" for a description of the algorithm.

     See also: ppval.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns the piecewise polynomial form of the Catmull-Rom cubic spline
interpo...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
csape


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 987
 -- Function File: PP = csape (X, Y, COND, VALC)
     cubic spline interpolation with various end conditions.  creates
     the pp-form of the cubic spline.

     X should be N by 1, Y should be N by M, VALC should be 2 by M or 2
     by 1

     The following end conditions as given in COND are possible:
     'complete'
          match slopes at first and last point as given in VALC
          (default; if VALC is not given, the slopes matched are those
          of the cubic polynomials that interpolate the first and last
          four points)
     'not-a-knot'
          third derivatives are continuous at the second and second last
          point
     'periodic'
          match first and second derivative of first and last point
     'second'
          match second derivative at first and last point as given in
          VALC
     'variational'
          set second derivative at first and last point to zero (natural
          cubic spline)

     See also: ppval, spline.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
cubic spline interpolation with various end conditions.  creates the
pp-form ...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
csapi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Function File: PP = csapi (X, Y)
 -- Function File: YI = csapi (X, Y, XI)
     cubic spline interpolation

     See also: ppval, spline, csape.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
cubic spline interpolation



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
csaps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1815
 -- Function File: [YI P SIGMA2 UNC_YI DF] = csaps(X, Y, P, XI, W=[])
 -- Function File: [PP P SIGMA2] = csaps(X, Y, P, [], W=[])

     Cubic spline approximation (smoothing)
     approximate [X,Y], weighted by W (inverse variance of the Y values;
     if not given, equal weighting is assumed), at XI

     The chosen cubic spline with natural boundary conditions PP(X)
     minimizes P * Sum_i W_i*(Y_i - PP(X_i))^2 + (1-P) * Int PP"(X) dX

     Outside the range of X, the cubic spline is a straight line

     X and W should be n by 1 in size; Y should be n by m; XI should be
     k by 1; the values in X should be distinct and in ascending order;
     the values in W should be nonzero

     P=0
          maximum smoothing: straight line
     P=1
          no smoothing: interpolation
     P<0 or not given
          an intermediate amount of smoothing is chosen
          and the corresponding P between 0 and 1 is returned
          (such that the smoothing term and the interpolation term are
          of the same magnitude)
          (csaps_sel provides other methods for automatically selecting
          the smoothing parameter P.)

     SIGMA2 is an estimate of the data error variance, assuming the
     smoothing parameter P is realistic

     UNC_YI is an estimate of the standard error of the fitted curve(s)
     at the XI.  Empty if XI is not provided.

     DF is an estimate of the degrees of freedom used in the spline fit
     (2 for P=0, n for P=1)

     References:
     Carl de Boor (1978), A Practical Guide to Splines, Springer,
     Chapter XIV
     Grace Wahba (1983), Bayesian "confidence intervals" for the
     cross-validated smoothing spline, Journal of the Royal Statistical
     Society, 45B(1):133-150

See also: spline, splinefit, csapi, ppval, dedup, bin_values, csaps_sel.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Cubic spline approximation (smoothing)
approximate [X,Y], weighted by W (inve...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
csaps_sel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3284
 -- Function File: [YI P SIGMA2,UNC_Y] = csaps_sel(X, Y, XI, W=[],
          CRIT=[])
 -- Function File: [PP P SIGMA2,UNC_Y] = csaps_sel(X, Y, [], W=[],
          CRIT=[])

     Cubic spline approximation with smoothing parameter estimation
     Approximately interpolates [X,Y], weighted by W (inverse variance;
     if not given, equal weighting is assumed), at XI.

     The chosen cubic spline with natural boundary conditions PP(X)
     minimizes P Sum_i W_i*(Y_i - PP(X_i))^2 + (1-P) Int PP"(X) dX.

     A selection criterion CRIT is used to find a suitable value for P
     (between 0 and 1); possible values for CRIT are 'vm' (Vapnik's
     measure [Cherkassky and Mulier 2007] from statistical learning
     theory); 'aicc' (corrected Akaike information criterion, the
     default); 'aic' (original Akaike information criterion); 'gcv'
     (generalized cross validation).

     If CRIT is a nonnegative scalar instead of a string, then P is
     chosen to so that the mean square scaled residual Mean_i (W_i*(Y_i
     - PP(X_i))^2) is approximately equal to CRIT.  If CRIT is a
     negative scalar, then P is chosen so that the effective number of
     degrees of freedom in the spline fit (which ranges from 2 when P =
     0 to N when P = 1) is approximately equal to -CRIT.

     X and W should be N by 1 in size; Y should be N by M; XI should be
     K by 1; the values in X should be distinct and in ascending order;
     the values in W should be nonzero.

     Returns the smoothing spline PP or its values YI at the desired XI;
     the selected P; the estimated data scatter (variance from the
     smooth trend) SIGMA2; the estimated uncertainty (SD) of the
     smoothing spline fit at each X value, UNC_Y; and the estimated
     number of degrees of freedom DF (out of N) used in the fit.

     For small N, the optimization uses singular value decomposition of
     an N by N matrix in order to quickly compute the residual size and
     model degrees of freedom for many P values for the optimization
     (Craven and Wahba 1979).  For large N (currently >300), an
     asymptotically more computation and storage efficient method that
     takes advantage of the sparsity of the problem's coefficient
     matrices is used (Hutchinson and de Hoog 1985).

     References:

     Vladimir Cherkassky and Filip Mulier (2007), Learning from Data:
     Concepts, Theory, and Methods.  Wiley, Chapter 4

     Carl de Boor (1978), A Practical Guide to Splines, Springer,
     Chapter XIV

     Clifford M. Hurvich, Jeffrey S. Simonoff, Chih-Ling Tsai (1998),
     Smoothing parameter selection in nonparametric regression using an
     improved Akaike information criterion, J. Royal Statistical
     Society, 60B:271-293

     M. F. Hutchinson and F. R. de Hoog (1985), Smoothing noisy data
     with spline functions, Numerische Mathematik, 47:99-106

     M. F. Hutchinson (1986), Algorithm 642: A fast procedure for
     calculating minimum cross-validation cubic smoothing splines, ACM
     Transactions on Mathematical Software, 12:150-153

     Grace Wahba (1983), Bayesian "confidence intervals" for the
     cross-validated smoothing spline, J Royal Statistical Society,
     45B:133-150

See also: csaps, spline, csapi, ppval, dedup, bin_values, gcvspl.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Cubic spline approximation with smoothing parameter estimation
Approximately ...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dedup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 806
 -- Function File: [X_NEW Y_NEW W_NEW] = dedup(X, Y, W, TOL,
          NAN_REMOVE=true)

     De-duplication and sorting to facilitate spline smoothing
     Points are sorted in ascending order of X, with each set of
     duplicates (values with the same X, within TOL) replaced by a
     weighted average.  Any NaN values are removed (if the flag
     NAN_REMOVE is set).

     Useful, for example, as a preprocessor to spline smoothing

     Inputs:
     X: N*1 real array
     Y: N*M array of values at the coordinates X
     W: N*1 array of positive weights (inverse error variances);
     'ones(size(x))' by default
     TOL: if the difference between two X values is no more than this
     scalar, merge them; 0 by default

     Outputs: De-duplicated and sorted X, Y, W

See also: csaps, bin_values.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
De-duplication and sorting to facilitate spline smoothing
Points are sorted i...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fnder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Function File: fnder (PP, ORDER)
     differentiate the spline in pp-form

     See also: ppval.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
differentiate the spline in pp-form



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fnplt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 -- Function File: fnplt (PP, 'PLT')
     plots spline

     See also: ppval, spline, csape.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
plots spline



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fnval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 r = fnval(pp,x) or r = fnval(x,pp)
 Compute the value of the piece-wise polynomial pp at points x.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 r = fnval(pp,x) or r = fnval(x,pp)
 Compute the value of the piece-wise poly...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
regularization


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1860
 -- Function File: [GRID,U] = regularization (DATA, INTERVAL, N, F1)
 -- Function File: [GRID,U] = regularization (DATA, INTERVAL, N, F1, F2)

     Apply a Tikhonov regularization, the functional to be minimized is
     F = FD + LAMBDA1*F1 + LAMBDA2*F2
     = sum_(i=1)^M (y_i-u(x_i))^2 + LAMBDA1*int_a^b (u'(x) - G1(x))^2 dx
     + LAMBDA2*int_a^b (u"(x) - G2(x))^2 dx

     With LAMBDA1 = 0 and G2(x) = 0 this leads to a smoothing spline.

     Parameters:
        * DATA is a M*2 matrix with the x values in the first column and
          the y values in the second column.
        * INTERVAL = [a,b] is the interval on which the regularization
          is applied.
        * N is the number of subintervals of equal length.  GRID will
          consist of N+1 grid points.
        * F1 is a structure containing the information on the first
          regularization term, integrating the square of the first
          derivative.
             * F1.LAMBDA is the value of the regularization parameter
               LAMBDA1>=0.
             * F1.G is the function handle for the function G1(X).  If
               not provided G1=0 is used.
        * F2 is a structure containing the information on the second
          regularization term, integrating the square of the second
          derivative.  If F2 is not provided LAMBDA2=0 is assumed.
             * F2.LAMBDA is the value of the regularization parameter
               LAMBDA2>=0.
             * F2.G is the function handle for the function G2(X).  If
               not provided G2=0 is used.

     Return values:
        * GRID is the grid on which U is evaluated.  It consists of N+1
          equidistant points on the INTERVAL.
        * U are the values of the regularized approximation to the DATA
          evaluated at GRID.

     See also: csaps, regularization2D, demo regularization.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Apply a Tikhonov regularization, the functional to be minimized is
F = FD + L...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
regularization2D


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1526
 -- Function File: [GRID,U,DATA_VALID] = regularization2D (DATA, BOX, N,
          LAMBDA1,LAMBDA2)

     Apply a Tikhonov regularization, the functional to be minimized is
     F = FD + LAMBDA1 * F1 + LAMBDA2 * F2
     = sum_(i=1)^M (y_i-u(x_i))^2 +
     + LAMBDA1 * dintegral (du/dx)^2+(du/dy)^2 dA +
     + LAMBDA2 * dintegral (d^2u/dx^2)^2+(d^2u/dy^2)^2+2*(d^2u/dxdy) dA

     With LAMBDA1 = 0 and LAMBDA2>0 this leads to a thin plate smoothing
     spline.

     Parameters:
        * DATA is a M*3 matrix with the (x,y) values in the first two
          columns and the y values in the third column.
          Only data points strictly inside the BOX are used
        * BOX = [x0,x1;y0,y1] is the rectangle x0<x<x1 and y0<y<y1 on
          which the regularization is applied.
        * N = [N1,N2] determines the number of subintervals of equal
          length.  GRID will consist of (N1+1)x(N2+1) grid points.
        * LAMBDA1 >= 0 is the value of the first regularization
          parameter
        * LAMBDA2 > 0 is the value of the secondregularization parameter

     Return values:
        * GRID is the grid on which U is evaluated.  It consists of
          (N1+1)x(N2+1) equidistant points on the the rectangle BOX.
        * U are the values of the regularized approximation to the DATA
          evaluated on the GRID.
        * DATA_VALID returns the values data points used and the values
          of the regularized function at these points

     See also: tpaps, regularization, demo regularization2D.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Apply a Tikhonov regularization, the functional to be minimized is
F = FD + L...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
tpaps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1872
 -- Function File: [YI P] = tpaps(X, Y, P, XI)
 -- Function File: [COEFS P] = tpaps(X, Y, P, [])

     Thin plate smoothing of scattered values in multi-D
     approximately interpolate [X,Y] at XI

     The chosen thin plate spline minimizes the sum of squared
     deviations from the given points plus a penalty term proportional
     to the curvature of the spline function

     X should be N by D in size, where N is the number of points and D
     the number of dimensions; Y and W should be N by 1; XI should be K
     by D; the points in X should be distinct

     P=0
          maximum smoothing: flat surface
     P=1
          no smoothing: interpolation
     P<0 or not given
          an intermediate amount of smoothing is chosen (such that the
          smoothing term and the interpolation term are of the same
          magnitude)

     If XI is not specified, returns a vector COEFS of the N + D + 1
     fitted thin plate spline coefficients.  Given COEFS, the value of
     the thin-plate spline at any XI can be determined with 'tps_val'

     Note: Computes the pseudoinverse of an N by N matrix, so not
     recommended for very large N

     Example usages:
          x = ([1:10 10.5 11.3])'; y = sin(x); xi = (0:0.1:12)';
          yi = tpaps(x, y, 0.5, xi);
          plot(x, y, xi, yi)

          x = rand(100, 2)*2 - 1;
          y = x(:, 1) .^ 2 + x(:, 2) .^ 2;
          scatter(x(:, 1), x(:, 2), 10, y, "filled")
          [x1 y1] = meshgrid((-1:0.2:1)', (-1:0.2:1)');
          xi = [x1(:) y1(:)];
          yi = tpaps(x, y, 1, xi);
          contourf(x1, y1, reshape(yi, 11, 11))

     Reference: David Eberly (2011), Thin-Plate Splines,
     www.geometrictools.com/Documentation/ThinPlateSplines.pdf
     Bouhamidi, A. (2005) Weighted thin plate splines, Analysis and
     Applications, 3: 297-324

See also: csaps, tps_val, tps_val_der.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Thin plate smoothing of scattered values in multi-D
approximately interpolate...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tps_val


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 701
 -- Function File: [YI] = tps_val(X, COEFS, XI, VECTORIZE=true)

     Evaluates a thin plate spline at given points
     XI

     COEFS should be the vector of fitted coefficients returned from
     'tpaps(x, y, [p])'

     X should be N by D in size, where N is the number of points and D
     the number of dimensions; COEFS should be N + D + 1 by 1; XI should
     be K by D

     The logical argument VECTORIZE controls whether an K by N by D
     intermediate array is formed to speed up computation (the default)
     or whether looping is used to economize on memory

     The returned YI will be K by 1

     See the documentation to 'tpaps' for more information

See also: tpaps, tps_val_der.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Evaluates a thin plate spline at given points
XI



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
tps_val_der


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1942
 -- Function File: [DYI] = tps_val_der(X, COEFS, XI, VECTORIZE=true )

     Evaluates the first derivative of a thin plate spline at given
     points
     XI

     COEFS should be the vector of fitted coefficients returned from
     'tpaps(x, y, [p])'

     X should be N by D in size, where N is the number of points and D
     the number of dimensions; COEFS should be (N + D + 1) by 1; XI
     should be K by D

     The logical argument VECTORIZE controls whether K by N by D
     intermediate arrays are formed to speed up computation (the
     default) or whether looping is used to economize on memory

     The returned DYI will be K by D, containing the first partial
     derivatives of the thin plate spline at XI

     Example usages:
          x = ([1:10 10.5 11.3])'; y = sin(x); dy = cos(x); xi = (0:0.1:12)';
          coefs = tpaps(x, y, 0.5);
          [dyi] = tps_val_der(x,coefs,xi);
          subplot(1, 1, 1)
          plot(x, dy, 's', xi, dyi)
          legend('original', 'tps')

          x = rand(100, 2)*2 - 1;
          y = x(:, 1) .^ 2 + x(:, 2) .^ 2;
          [x1 y1] = meshgrid((-1:0.2:1)', (-1:0.2:1)');
          xi = [x1(:) y1(:)];
          coefs = tpaps(x, y, 1);
          dyio = [2*x1(:) 2*y1(:)];
          [dyi] = tps_val_der(x,coefs,xi);
          subplot(2, 2, 1)
          contourf(x1, y1, reshape(dyio(:, 1), 11, 11)); colorbar
          title('original x1 partial derivative')
          subplot(2, 2, 2)
          contourf(x1, y1, reshape(dyi(:, 1), 11, 11)); colorbar
          title('tps x1 partial derivative')
          subplot(2, 2, 3)
          contourf(x1, y1, reshape(dyio(:, 2), 11, 11)); colorbar
          title('original x2 partial derivative')
          subplot(2, 2, 4)
          contourf(x1, y1, reshape(dyi(:, 2), 11, 11)); colorbar
          title('tps x2 partial derivative')

     See the documentation to 'tpaps' for more information

See also: tpaps, tpaps_val, tps_val_der.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Evaluates the first derivative of a thin plate spline at given points
XI





